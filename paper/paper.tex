\documentclass[]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Ligatures=TeX,Scale=MatchLowercase}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{%
\usepackage[]{microtype}
\UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\PassOptionsToPackage{hyphens}{url} % url is loaded by hyperref
\usepackage[unicode=true]{hyperref}
\hypersetup{
            pdfborder={0 0 0},
            breaklinks=true}
\urlstyle{same}  % don't use monospace font for urls
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\newenvironment{Shaded}{}{}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.53,0.00,0.00}{#1}}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.73,0.40,0.53}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{#1}}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.73,0.13,0.13}{\textit{#1}}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.10,0.09,0.49}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.40,0.40,0.40}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.74,0.48,0.00}{#1}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.49,0.56,0.16}{#1}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\usepackage{longtable,booktabs}
% Fix footnotes in tables (requires footnote package)
\IfFileExists{footnote.sty}{\usepackage{footnote}\makesavenoteenv{long table}}{}
\IfFileExists{parskip.sty}{%
\usepackage{parskip}
}{% else
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{0}
% Redefines (sub)paragraphs to behave more like sections
\ifx\paragraph\undefined\else
\let\oldparagraph\paragraph
\renewcommand{\paragraph}[1]{\oldparagraph{#1}\mbox{}}
\fi
\ifx\subparagraph\undefined\else
\let\oldsubparagraph\subparagraph
\renewcommand{\subparagraph}[1]{\oldsubparagraph{#1}\mbox{}}
\fi

% set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother


\date{}

\begin{document}

\section{Optimizarea fisierelor Java}\label{optimizarea-fisierelor-java}

\section{Abstract}\label{abstract}

In acest paper voi descrie incercarea mea de a crea un optimizator de
spatiu pentru fisierele .class ale limbajului Java.

Acest optimizator se bazeaza pe analiza statica a fisierelor pentru
eliminarea metodelor nefolosite din cadrul fisierelor.

Voi analiza structura fisierelor, voi explica modul de analiza alor si
voi expune modul de eliminare a metodelor.

\section{Introducere}\label{introducere}

\subsection{Java}\label{java}

Java este un limbaj de programare orientat pe obiecte. Acesta a fost
dezvoltat de catre Sun Microsystems ( acum Oracle), iar prima versiune a
aparut in anul 1995.

Jaza s-a bazat pe sintaxa limbajului C, si a introdus notiunea de
``scrie o data, ruleaza peste tot'' (eng. ``write once, run
everywhere''). Spre deosebire de C si de C++, care trebuiesc compilate
pentru fiecare platforma tinta, Java a avut avantajul ca trebuie
compilat o singura data, si va merge garantat pe toate platformele
suportate de limbaj.

\subsubsection{Java Bytecode}\label{java-bytecode}

Solutia limbajului Java pentru a fi independent de platforma este de
transforma codul intr-o reprezentare intermediara, in loc de direct in
cod binary pentru o anumita arhitectura .

Compilatorul Java (\texttt{javac}), transforma codul Java intr-un limbaj
intermediar, numit Java Bytecode.

Acest limbaj este un limbaj low-level, destinat in mod exclusiv
procesarii de catre masini, spre deosebire de codul Java, care este
destinat oamenilor.

Dupa ce compilatorul a procesat codul Java, provenit din fisere .java in
format text, acesta salveaza rezultatul in fisiere de tip clasa (.class)
in format binar.

\subsubsection{Masina Virtuala Java
	(JVM)}\label{masina-virtuala-java-jvm}

Odata generate fisierele binare, acestea sunt executate pe o masina
virtuala specifica limbajului Java - numita JVM sau \texttt{The\ JVM}
(eng. Java Virtual Machine).

Aceasta masina virtuala are rolul de a citi fisierele de clasa binare si
de a le interpreta.

Masina virtuala este implementata ca o ``masina cu stiva'' (eng. stack
machine), unde toate instructiunile limbajului bytecode interactioneaza
cu datele de pe o stiva controlata de aplicatie.

Masina virtuala insusi este implementata in C/C++, si este compilata in
cod binar direct, dependent de arhitectura. Dezvoltatorii limbajului
Java sunt responsabili pentru corectitudinea si siguranta masinii
virtuale, in timp ce dezvoltatorii de aplicatii Java au garantia ca daca
codul lor Java este corect, atunci acesta va rula la fel, deterministic,
pe orice platforma.

In acest regard, limbajul Java poate fi vazut ca un limbaj interpretat.
Comparand cu alte limbaje populare interpretate, ca de exemplu Python,
Ruby, sau Perl, ne-am astepta ca si Java sa fie la fel de incet ca
acestea {[}1{]}. Totusi, Java obtine performante mult mai bune decat
aceastea. Acest fapt se datoreaza compilarii tocmai-la-timp (eng.
just-in-time), in care atunci cand interpretorul observa o secventa de
cod care este interpretata repetitiv de foarte multe ori, va genera
direct cod binary pentru aceasta.

\section{Fisierele de clasa}\label{fisierele-de-clasa}

Fisierele de clasa Java sunt formate din 10 sectiuni{[}2{]}:

\begin{enumerate}
	\def\labelenumi{\arabic{enumi}.}
	\tightlist
	\item
	      Constanta magica.
	\item
	      Versiunea fisierului.
	\item
	      Constantele clasei.
	\item
	      Permisiunile de acces.
	\item
	      Numele clasei din fisier.
	\item
	      Numele superclasei.
	\item
	      Interfetele pe care clasa le implementeaza.
	\item
	      Campurile clasei.
	\item
	      Metodele clasei.
	\item
	      Atribute ale clasei.
\end{enumerate}

In continuare voi da o scurta descriere a formatului sectiunilor.

\subsection{Sectiunile fiserelor
	clasa}\label{sectiunile-fiserelor-clasa}

\subsubsection{Magic}\label{magic}

Toate fiserele clasa trebuiesc sa inceapa cu un numar denumit constanta
magica. Acesta este folosit pentru a identifica in mod unic ca acestea
sunt intra-devar fisiere clasa. Numarul magic are o valoare memorabila:
reprezentarea hexadecimala este \texttt{0xCAFEBABE},

\subsubsection{Versiunea}\label{versiunea}

Versiunea unui fisier clasa este data de doua valori, versiunea majora
\texttt{M} si versiunea minora \texttt{m}. Versiunea clasei este atunci
reprezentata ca \texttt{M.m}. (e.g., \texttt{45.1}). Aceasta este
folosita pentru a mentine compatibilitatea in cazul modificarilor
masinii virtuale care interpreteaza clasa sau ale compilatorului care o
genereaza.

\subsubsection{Constantele clasei}\label{constantele-clasei}

Tabela de constante este locul unde sunt stocate valorile literale
constante ale clasei: * Numere intregi. * Numere cu virgula mobula. *
Siruri de caractere, care pot reprezenta la randul lor: * Nume de clase.
* Nume de metode. * Tipuri ale metodelor. * Informatii compuse din
datele anterioare: * Referinta la o metoda a unei clase. * Referinta la
o constanta a unei clase.

Toate celelalte tipuri de date compuse, cum ar fi metodele sau
campurile, vor contine indecsi in tabela de constante.

\subsubsection{Permisiunile de acces}\label{permisiunile-de-acces}

Aceste permisiuni constau intr-o masca de bitsi, care reprezeinta
operatiile permise pe aceasta clasa:

\begin{verbatim}
* daca clasa este publica, si poate fi accesta din afara pachetului acesteia.
* daca clasa este finala, si daca poate fi extinsa.
* daca invocarea metodelor din superclasa sa fie tratata special.
* daca este de fapt o interfata, si nu o clasa.
* daca este o clasa abstracta si nu poate fi instatiata.
\end{verbatim}

\subsubsection{Clasa curenta}\label{clasa-curenta}

Reprezinta un indice in tabela de constante, unde sunt stocate
informatii despre clasa curenta.

\subsubsection{Clasa super}\label{clasa-super}

Reprezinta un indice in tabela de consatante, cu informatii despre clasa
din care a mostenit clasa curenta. Daca este 0, inseamna ca clasa
curenta nu mosteneste nimic: singura clasa fara o superclasa este clasa
\texttt{Object}.

E.g. pentru

\begin{Shaded}
	\begin{Highlighting}[]
		\KeywordTok{class}\NormalTok{ MyClass }\KeywordTok{extends}\NormalTok{ SuperClass }\KeywordTok{implements}\NormalTok{ Interface1, Interface \{}
		\NormalTok{    ....}
		\NormalTok{\}}
	\end{Highlighting}
\end{Shaded}

Indicele corespunde lui \texttt{SuperClass}.

\subsubsection{Interfetele}\label{interfetele}

Reprezinta o colectie de indici in tabela de constante. Fiecare valoare
de la acei indici reprezinta o interfata implementata in mod direct de
catre clasa curenta. Interfetele apar in ordinea declarata in fisierele
java.

E.g. pentru

\begin{Shaded}
	\begin{Highlighting}[]
		\KeywordTok{class}\NormalTok{ MyClass }\KeywordTok{extends}\NormalTok{ SuperClass }\KeywordTok{implements}\NormalTok{ Interface1, Interface2 \{}
		\NormalTok{    ...}
		\NormalTok{\}}
	\end{Highlighting}
\end{Shaded}

Primul indice ar corespunde lui \texttt{Interface}, iar al doilea lui
\texttt{Interface2}.

\subsubsection{Campurile}\label{campurile}

Reprezinta informatii despre campurile (eng. fields) clasei: *
Permisiunile de acces: daca este public sau privat, etc. * Numele
campului. * Tipul campului. * Alte atribute: daca este deprecat, daca
are o valoare constanta, etc.

\subsubsection{Metodele}\label{metodele}

Reprezinta informtii despre toate metodele clasei, si include si
constructorii:

\begin{verbatim}
* Permisiuni de acces: daca este public sau privat, daca este finala, daca este abstracta.
* Numele metodei.
* Tipul metodei.
* In caz ca nu este abstracta, byte codul metodei.
* Alte atribute:
    * Ce exceptii poate arunca.
    * Daca este deprecata.
\end{verbatim}

Codul metodei este partea cea mai importanta, iar formatul acestuia
urmeaza sa fie detaliat ulterior.

\subsubsection{Atributele}\label{atributele}

Reprezinta alte informatii despre clasa, cum ar fi: * Clasele definite
in interiorul acesteia. * In caz ca este o clasa anonima sau definita
local, metoda in care este definita. * Numele fisierul sursa din care a
fost compilata clasa.

In continuare, voi descrie din punct de vedere tehnic tipurile de date
intalnite in fisierele de clasa:

\subsubsection{Tipurile de baza}\label{tipurile-de-baza}

In formatul fisierelor clasa exista trei tipuri de baza, toate bazate pe
intregi. In caz ca un intreg are mai multi octeti, acestia au ordinea de
\texttt{big-endian}: cel mai semnificativ octet va fi mereu primul in
memorie.

\begin{longtable}[]{@{}ccc@{}}
	\toprule
	Nume        & Semantica                       & Echivalentul in C\tabularnewline
	\midrule
	\endhead
	\texttt{u1} & intreg pe un octet, fara semn   & \texttt{unsigned\ char}
	sau \texttt{uint8\_t}\tabularnewline
	\texttt{u2} & intreg pe doi octeti, fara semn & \texttt{unsigned\ short}
	sau \texttt{uint16\_t}\tabularnewline
	\texttt{u4} & intreg pe un octet, fara semn   & \texttt{unsigned\ int} sau
	\texttt{uint32\_t}\tabularnewline
	\bottomrule
\end{longtable}

In codul sursa al proiectului, acestea sunt tratate astfel:

\begin{Shaded}
	\begin{Highlighting}[]
		\KeywordTok{using}\NormalTok{ u1 = }\DataTypeTok{uint8_t}\NormalTok{;}
		\KeywordTok{using}\NormalTok{ u2 = }\DataTypeTok{uint16_t}\NormalTok{;}
		\KeywordTok{using}\NormalTok{ u4 = }\DataTypeTok{uint32_t}\NormalTok{;}
	\end{Highlighting}
\end{Shaded}

\subsubsection{Tipuri de date compuse}\label{tipuri-de-date-compuse}

\paragraph{cp\_info}\label{cp_info}

Fiecare constanta din tabela de constante incepe cu o eticheta de 1
octet, care reprezinta datele si tipul structurii. Continutul acesteia
variaza in functie de eticheta, insa indiferent de eticheta, continutul
trebuie sa aiba cel putin 2 octeti.

Aproape toate tipurile de constante ocupa un singur slot in tabela.
Insa, din motive istorice, unele constante ocupa doua sloturi.

Totodata, tot din motive istorice, tabela este indexata de la 1, si nu
de la 0, cum sunt celelalte.

\subparagraph{Tipurile de constante}\label{tipurile-de-constante}

\texttt{CONSTANT\_Class}

Corespunde valorii etichetei de 7 si contine un indice spre un alt camp
in tabela de constante, de tipul \texttt{CONSTANT\_Utf8} - un sir de
caractere. Acel sir de caractere va contine numele clasei.

\texttt{CONSTANT\_Fieldref}

Corespunde valorii etichetei de 9 si contine o referinta spre campul
unei clase. Referinta conta in doi indici, amandoi care arata spre
tabela de contante. Primul indice arata spre o constanta
\texttt{CONSTANT\_Class}, care reprezinta clasa sau interfata careia
apartine metoda. Al doilea indice arata spre o constanta
\texttt{CONSTANT\_NameAndType}, care contine informatii despre numele si
tipul campului.

\texttt{CONSTANT\_Methodref}

Corespunde valorii etichetei de 10 si contine o referinta spre metoda
unei clase. Are o structura identica cu \texttt{CONSTANT\_Fieldref},
doar ca primul indice arata neaparat spre o clasa, in timp ce al doilea
indice arata spre numele si tipul metodei.

\texttt{CONSTANT\_InterfaceMethodref}

Corespunde valorii etichetei de 11 si contine o refereinta spre metoda
unei interfete. Are o structura identica cu
\texttt{CONSTANT\_Methodref}, doar ca primul indice arata spre o
interfata.

\texttt{CONSTANT\_String}

Corespunde valorii etichetei de 8 si reprezinta un sir de caractere.
Contine un indice, catre o structura de tipul \texttt{CONSTANT\_Utf8}.

\texttt{CONSTANT\_Integer}

Corespunde valorii etichetei de 3 si contine un intreg pe 4 octeti.

\texttt{CONSTANT\_Float}

Corespunde valorii etichetei de 4 si contine un numar cu virgula mobila
pe 4 octeti.

\texttt{CONSTANT\_Long}

Corespunde valorii etichetei de 5 si contine un intreg pe 8 octeti. Din
motive istorice, ocupa 2 spatii in tabela de constante.

\texttt{CONSTANT\_Double}

Corespunde valorii etichetei de 6 si contine un numar cu virgula mobila
pe 8 octeti. Din motive istorice, ocupa 2 spatii in tabela de constante.

\texttt{CONSTANT\_NameAndType}

Corespunde valorii etichetei de 12. Descrie numele si tipul unui camp
sau al unei metode, fara informatii despre clasa. Contine doi indici,
amandoi catre structuri de tipul \texttt{CONSTANT\_Utf8}. Primul
reprezinta numele, iar al doilea tipul.

\texttt{CONSTANT\_Utf8}

Corespunde valorii etichetei de 1. Reprezinta un sir de caractere
encodat in formatul UTF-8. Contine un intreg \texttt{length}, de tipul
\texttt{u2}, si apoi \texttt{length} octeti care descriu sirul in sine.
Din cauza ca este encodat ca UTF-8, un singur caracter poate fi format
din mai multi octeti.

\texttt{CONSTANT\_MethodHandle}

Corespunde valorii etichetei de 15 si contine o referinte catre un camp,
o metoda de clasa, sau o metoda de interfata.

\texttt{CONSTANT\_MethodType}

Corespunde valorii etichetei de 16 si contine un indice catre o
constanta \texttt{CONSTANT\_UTf8}, ce reprezinta tipul unei metode.

\texttt{CONSTANT\_InvokeDynamic}

Corespunde valorii etichetei de 18 si este folosit de catre \texttt{JVM}
pentru a invoka o metoda polimorfica.

In cod \texttt{C++}, am reprezentat \texttt{cp\_info} astfel:

\begin{Shaded}
	\begin{Highlighting}[]
		\KeywordTok{struct}\NormalTok{ cp_info \{}
		\KeywordTok{enum} \KeywordTok{class}\NormalTok{ Tag : u1 \{}
		\NormalTok{        CONSTANT_Class = }\DecValTok{7}\NormalTok{,}
		\NormalTok{        CONSTANT_Fieldref = }\DecValTok{9}\NormalTok{,}
		\NormalTok{        CONSTANT_Methodref = }\DecValTok{10}\NormalTok{,}
		\NormalTok{        CONSTANT_InterfaceMethodref = }\DecValTok{11}\NormalTok{,}
		\NormalTok{        CONSTANT_String = }\DecValTok{8}\NormalTok{,}
		\NormalTok{        CONSTANT_Integer = }\DecValTok{3}\NormalTok{,}
		\NormalTok{        CONSTANT_Float = }\DecValTok{4}\NormalTok{,}
		\NormalTok{        CONSTANT_Long = }\DecValTok{5}\NormalTok{,}
		\NormalTok{        CONSTANT_Double = }\DecValTok{6}\NormalTok{,}
		\NormalTok{        CONSTANT_NameAndType = }\DecValTok{12}\NormalTok{,}
		\NormalTok{        CONSTANT_Utf8_info = }\DecValTok{1}\NormalTok{,}
		\NormalTok{        CONSTANT_MethodHandle = }\DecValTok{15}\NormalTok{,}
		\NormalTok{        CONSTANT_MethodType = }\DecValTok{16}\NormalTok{,}
		\NormalTok{        CONSTANT_InvokeDynamic = }\DecValTok{18}\NormalTok{,}
		\NormalTok{    \};}

		\NormalTok{    Tag tag;}
		\BuiltInTok{std::}\NormalTok{vector<u1> data;}
		\NormalTok{\};}
	\end{Highlighting}
\end{Shaded}

Iar structurile folosite pentru obiectivul propus au fost reprezentate
astfel:

\begin{Shaded}
	\begin{Highlighting}[]
		\KeywordTok{struct}\NormalTok{ CONSTANT_Methodref_info \{}
		\NormalTok{    cp_info::Tag tag;}
		\NormalTok{    u2 class_index;}
		\NormalTok{    u2 name_and_type_index;}
		\NormalTok{\};}
		\KeywordTok{struct}\NormalTok{ CONSTANT_Class_info \{}
		\NormalTok{    cp_info::Tag tag;}
		\NormalTok{    u2 name_index;}
		\NormalTok{\};}
		\KeywordTok{struct}\NormalTok{ CONSTANT_NameAndType_info \{}
		\NormalTok{    cp_info::Tag tag;}
		\NormalTok{    u2 name_index;}
		\NormalTok{    u2 descriptor_index;}
		\NormalTok{\};}
	\end{Highlighting}
\end{Shaded}

\paragraph{\texorpdfstring{\texttt{field\_info}}{field\_info}}\label{field_info}

Fiecare camp din cadrul unei clase este reprezentat printr-o structura
de tipul \texttt{field\_info}.

In cod \texttt{C++}, aceasta structura a fost reprezentata astfel:

\begin{Shaded}
	\begin{Highlighting}[]
		\KeywordTok{struct}\NormalTok{ field_info \{}
		\NormalTok{    u2 access_flags;}
		\NormalTok{    u2 name_index;}
		\NormalTok{    u2 descriptor_index;}
		\NormalTok{    u2 attributes_count;}
		\BuiltInTok{std::}\NormalTok{vector<attribute_info> attributes;}
		\NormalTok{\};}
	\end{Highlighting}
\end{Shaded}

Unde: * \texttt{name\_index} este o intrare in tabela de constante unde
se afla o constanta de tipul \texttt{CONSTANT\_Utf8}. *
\texttt{descriptor\_index} arata spre o constanta de tipul
\texttt{CONSTANT\_Utf8} si reprezinta tipul campului.

\paragraph{\texorpdfstring{\texttt{method\_info}}{method\_info}}\label{method_info}

Fiecare metoda a unei clase/interfete este descrisa prin aceasta
structura.

In cod \texttt{C++}, am implementat-o asa:

\begin{Shaded}
	\begin{Highlighting}[]
		\KeywordTok{struct}\NormalTok{ method_info \{}
		\NormalTok{    u2 access_flags;}
		\NormalTok{    u2 name_index;}
		\NormalTok{    u2 descriptor_index;}
		\NormalTok{    u2 attributes_count;}
		\BuiltInTok{std::}\NormalTok{vector<attribute_info> attributes;}
		\NormalTok{\};}
	\end{Highlighting}
\end{Shaded}

Unde \texttt{name\_index} si \texttt{descriptor\_index} au aceeasi
interpretare ca si la \texttt{field\_info}.

Daca metoda nu este abstracta, atunci in vectorul \texttt{attributes} se
va gasi un attribut de tipul \texttt{Code}, care contine bytecode-ul
corespunzator acestei metode.

\paragraph{\texorpdfstring{\texttt{attribute\_info}}{attribute\_info}}\label{attribute_info}

In \texttt{C++}, a fost implementata astfel:

\begin{Shaded}
	\begin{Highlighting}[]
		\KeywordTok{struct}\NormalTok{ attribute_info \{}
		\NormalTok{    u2 attribute_name_index;}
		\NormalTok{    u4 attribute_length;}
		\BuiltInTok{std::}\NormalTok{vector<u1> info;}
		\NormalTok{\};}
	\end{Highlighting}
\end{Shaded}

Numele atributului determina modul in care octetii din vectorul
\texttt{info} sunt interpretati. Pentru intentiile noastre, atributul de
interes este cel de cod:

\subparagraph{\texorpdfstring{\texttt{Code\_attribute}}{Code\_attribute}}\label{code_attribute}

\begin{Shaded}
	\begin{Highlighting}[]
		\KeywordTok{struct}\NormalTok{ Code_attribute \{}
		\NormalTok{    u2 attribute_name_index;}
		\NormalTok{    u4 attribute_length;}

		\NormalTok{    u2 max_stack;}
		\NormalTok{    u2 max_locals;}

		\NormalTok{    u4 code_length;}
		\BuiltInTok{std::}\NormalTok{vector<u1> code;}

		\NormalTok{    u2 exception_table_length;}
		\KeywordTok{struct}\NormalTok{ exception \{}
		\NormalTok{        u2 start_pc;}
		\NormalTok{        u2 end_pc;}
		\NormalTok{        u2 handler_pc;}
		\NormalTok{        u2 }\DataTypeTok{catch_type}\NormalTok{;}
		\NormalTok{    \};}
		\BuiltInTok{std::}\NormalTok{vector<exception> exception_table; }\CommentTok{// of length exception_table_length.}
		\NormalTok{    u2 attributes_count;}
		\BuiltInTok{std::}\NormalTok{vector<attribute_info> attributes; }\CommentTok{// of length attributes_count.}
		\NormalTok{\};}
	\end{Highlighting}
\end{Shaded}

Aceasta structura este piesa centrala a lucrarii. In continuare, o voi
descrie detaliat:

\begin{itemize}
	\tightlist
	\item
	      \texttt{max\_stack}: Reprezinta adancimea maxima a stivei masinii
	      virtuale cand aceasta bucata de cod este interpretata.
	\item
	      \texttt{max\_locals}: Reprezinta numarul maxim de variabile locale
	      alocate in acelasi timp cand aceasta bucata de cod este interpretata.
	\item
	      \texttt{code}: Codul metodei.
	\item
	      \texttt{exception\_table}: Exceptiile pe care le poate arunca metoda.
\end{itemize}

\texttt{Code}

Vectorul \texttt{code} din cadrul atributului \texttt{Code} reprezinta
bytecode-ul propriu-zis al metodei.

Acest vector contine instructiunile care sunt executate de catre masina
virtuala.

JVM-ul ruleaza ca o masina cu stiva, iar toate instructiunile opereaza
pe aceasta stiva. Reultatul rularii unei instructiuni este modificarea
stivei: scoaterea si adaugarea de elemente in varful acesteia.

Instructiunile au in general formatul {[}3{]}:

\begin{verbatim}
nume_instr
operand1
operand2
...
\end{verbatim}

cu un numar variabil de operanzi, prezenti in mod explicit in vectorul
de \texttt{cod}.

Fiecarui instructiuni ii corespunde un octet, denumit opcode. Fiecare
operand este fie cunoscut la compilare, fie calculat in mod dinamic la
rulare.

Cele mai multe operatii nu au niciun operand dat in mod explicit la
nivelul instructiunii: ele lucreaza doar cu valorile din varful stivei
la momentul executarii codului.

De exemplu:

Instructiunea \texttt{imul} are octetul \texttt{104} sau \texttt{0x68}.
Acestea da pop la doua valori din varful stivei: \texttt{value1} si
\texttt{value2}. Amandoua valorile trebuie sa fie de tipul \texttt{int}.
Rezultatul este inmultirea celor doua valori:
\texttt{result\ =\ value1\ *\ value2}, si este pus in varful stivei.

Dintre cele peste o suta de instructiuni, noi suntem preocupati doar de
5 dintre acestea: cele care au de a face cu invocarea unei metode.

invokedynamic

Format:

\begin{verbatim}
invokedynamic
index1
index2
0
0
\end{verbatim}

Opcode-ul corespunzator acestei instructiuni este \texttt{186} sau
\texttt{0xba}.

Index1 si index2 sunt doi octeti sunt compusi in

\begin{Shaded}
	\begin{Highlighting}[]
		\NormalTok{index = (index1 << }\DecValTok{8}\NormalTok{) | index2}
	\end{Highlighting}
\end{Shaded}

Indicele compus reprezinta o intrare in tabela de constante. La locatia
respectiva trebuie sa se afle o structura de tipul
\texttt{CONSTANT\_MethodHandle}

invokeinterface

Format:

\begin{verbatim}
invokeinterface
index1
index2
count
0
\end{verbatim}

Opcode-ul corespunzator este \texttt{185} sau \texttt{0xb9}.
\texttt{index1} si \texttt{index2} sunt folositi, in mod similar ca la
\texttt{invokedynamic}, pentru a construi un \texttt{indice} in tabela
de constante.

La pozitia respectiva in tabela, trebuie sa se regaseasca o strutura de
tipul \texttt{CONSTANT\_Methodref}.

\texttt{count} trebuie sa fie un octet fara semn diferit de 0. Acest
operand descrie numarul argumentelor metodei, si este necesar din motive
istorice: aceasta informatie poate fi dedusa din tipul metodei.

TODO(ericpts): add resolution order.

invokespecial

Format:

\begin{verbatim}
invokespecial
index1
index2
\end{verbatim}

Opcode-u corespunzator este \texttt{183} sau \texttt{0xb7}. La fel ca la
\texttt{invokeinterface}, este format un indice in tabela de constante,
catre o structura \texttt{CONSTANT\_Methodref}.

Aceasta instructiune este folosita pentru a invoca constructorii
claselor.

invokestatic

Format:

\begin{verbatim}
invokestatic
index1
index1
\end{verbatim}

Opcode-ul corespunzator este \texttt{184} sau \texttt{0xb8}.
Instructiunea este invocata pentru a invoke o metoda statica a unei
clase.

La fel ca la \texttt{invokeinterface}, este construit un indice compus,
si folosit pentru a indexa tabela de constante.

invokevirtual

Format:

\begin{verbatim}
invokevirtual
index1
index1
\end{verbatim}

Opcode-ul corespunzator este \texttt{182} sau \texttt{0xb6}, iar
interpretarea este la fel ca la \texttt{invokeinterface}.

Aceasta este cea mai comuna instructiune de invocare de functii.

Dupa ce numele si tipul metodei, cat si clasa \texttt{C} de care
apartine aceasta sunt rezolvate, masina virtuala cauta metoda respectiva
in clasa referentiata. In caz ca o gaseste, cautarea se termina. In caz
negativ, JVM va continua cautarea recursiv din superclasa lui
\texttt{C}.

In \texttt{C++}, am reprezentat aceste instructiuni de interes astfel:

\begin{Shaded}
	\begin{Highlighting}[]
		\KeywordTok{enum} \KeywordTok{class}\NormalTok{ Instr \{}
		\NormalTok{    invokedynamic = }\BaseNTok{0xba}\NormalTok{,}
		\NormalTok{    invokeinterface = }\BaseNTok{0xb9}\NormalTok{,}
		\NormalTok{    invokespecial = }\BaseNTok{0xb7}\NormalTok{,}
		\NormalTok{    invokestatic = }\BaseNTok{0xb8}\NormalTok{,}
		\NormalTok{    invokevirtual = }\BaseNTok{0xb6}\NormalTok{,}
		\NormalTok{\};}
	\end{Highlighting}
\end{Shaded}

\subsubsection{ClassFile}\label{classfile}

Folosind definitiile anterioare, putem descrie un fisier de clasa binar
in C++:

\begin{Shaded}
	\begin{Highlighting}[]
		\KeywordTok{struct}\NormalTok{ ClassFile \{}
		\NormalTok{    u4 magic; }\CommentTok{// Should be 0xCAFEBABE.}

		\NormalTok{    u2 minor_version;}
		\NormalTok{    u2 major_version;}

		\NormalTok{    u2 constant_pool_count;}
		\BuiltInTok{std::}\NormalTok{vector<cp_info> constant_pool;}

		\NormalTok{    u2 access_flags;}

		\NormalTok{    u2 this_class;}
		\NormalTok{    u2 super_class;}

		\NormalTok{    u2 interface_count;}
		\BuiltInTok{std::}\NormalTok{vector<interface_info> interfaces;}

		\NormalTok{    u2 field_count;}
		\BuiltInTok{std::}\NormalTok{vector<field_info> fields;}

		\NormalTok{    u2 method_count;}
		\BuiltInTok{std::}\NormalTok{vector<method_info> methods;}

		\NormalTok{    u2 attribute_count;}
		\BuiltInTok{std::}\NormalTok{vector<attribute_info> attributes;}
		\NormalTok{\};}
	\end{Highlighting}
\end{Shaded}

\section{Studiu de caz}\label{studiu-de-caz}

In continuare, voi exemplica structura unui fisier clasa cu un exemplu.

Codul Java este urmatorul:

\begin{Shaded}
	\begin{Highlighting}[]
		\KeywordTok{public} \KeywordTok{class}\NormalTok{ Main \{}
		\KeywordTok{public} \DataTypeTok{static} \DataTypeTok{void} \FunctionTok{main}\NormalTok{(}\BuiltInTok{String}\NormalTok{[] args) \{}
		\BuiltInTok{System}\NormalTok{.}\FunctionTok{out}\NormalTok{.}\FunctionTok{println}\NormalTok{(}\StringTok{"project1 - hello world"}\NormalTok{);}
		\FunctionTok{foo}\NormalTok{();}
		\NormalTok{    \}}

		\KeywordTok{public} \DataTypeTok{static} \DataTypeTok{void} \FunctionTok{foo}\NormalTok{() \{}
		\BuiltInTok{System}\NormalTok{.}\FunctionTok{out}\NormalTok{.}\FunctionTok{println}\NormalTok{(}\StringTok{"project1 - foo()"}\NormalTok{);}
		\NormalTok{    \}}
		\NormalTok{\}}
	\end{Highlighting}
\end{Shaded}

Compilatorul folosit este \texttt{openjdk-11}. Clasa a fost utilizata
folosind utilitarul \texttt{javap} {[}4{]}, care este de asemenea inclus
in pachetul \texttt{openjdk-11}.

In primul rand, tabela de constante:

\begin{verbatim}
Constant pool:
   #1 = Methodref          #8.#18         // java/lang/Object."<init>":()V
   #2 = Fieldref           #19.#20        // java/lang/System.out:Ljava/io/PrintStream;
   #3 = String             #21            // project1 - hello world
   #4 = Methodref          #22.#23        // java/io/PrintStream.println:(Ljava/lang/String;)V
   #5 = Methodref          #7.#24         // Main.foo:()V
   #6 = String             #25            // project1 - foo()
   #7 = Class              #26            // Main
   #8 = Class              #27            // java/lang/Object
   #9 = Utf8               <init>
  #10 = Utf8               ()V
  #11 = Utf8               Code
  #12 = Utf8               LineNumberTable
  #13 = Utf8               main
  #14 = Utf8               ([Ljava/lang/String;)V
  #15 = Utf8               foo
  #16 = Utf8               SourceFile
  #17 = Utf8               Main.java
  #18 = NameAndType        #9:#10         // "<init>":()V
  #19 = Class              #28            // java/lang/System
  #20 = NameAndType        #29:#30        // out:Ljava/io/PrintStream;
  #21 = Utf8               project1 - hello world
  #22 = Class              #31            // java/io/PrintStream
  #23 = NameAndType        #32:#33        // println:(Ljava/lang/String;)V
  #24 = NameAndType        #15:#10        // foo:()V
  #25 = Utf8               project1 - foo()
  #26 = Utf8               Main
  #27 = Utf8               java/lang/Object
  #28 = Utf8               java/lang/System
  #29 = Utf8               out
  #30 = Utf8               Ljava/io/PrintStream;
  #31 = Utf8               java/io/PrintStream
  #32 = Utf8               println
  #33 = Utf8               (Ljava/lang/String;)V
\end{verbatim}

In acest format, namespace-urile imbricate sunt reprezentate prin
\texttt{/}.

Informatii despre clasa:

\begin{verbatim}
Classfile Main.class
  Last modified May 28, 2018; size 520 bytes
  MD5 checksum 248b729dfe4b4bc8da895944d30fdc28
  Compiled from "Main.java"
public class Main
  minor version: 0
  major version: 55
  flags: (0x0021) ACC_PUBLIC, ACC_SUPER
  this_class: #7                          // Main
  super_class: #8                         // java/lang/Object
  interfaces: 0, fields: 0, methods: 3, attributes: 1
\end{verbatim}

Constructorul clasei:

\begin{verbatim}
{
  public Main();
    descriptor: ()V
    flags: (0x0001) ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object."<init>":()V
         4: return
      LineNumberTable:
        line 1: 0
\end{verbatim}

Metoda \texttt{main(String{[}{]}\ args)}:

\begin{verbatim}
public static void main(java.lang.String[]);
descriptor: ([Ljava/lang/String;)V
flags: (0x0009) ACC_PUBLIC, ACC_STATIC
Code:
  stack=2, locals=1, args_size=1
     0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
     3: ldc           #3                  // String project1 - hello world
     5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
     8: invokestatic  #5                  // Method foo:()V
    11: return
  LineNumberTable:
    line 3: 0
    line 4: 8
    line 5: 11
\end{verbatim}

Metoda \texttt{foo()}:

\begin{verbatim}
public static void foo();
descriptor: ()V
flags: (0x0009) ACC_PUBLIC, ACC_STATIC
Code:
  stack=2, locals=0, args_size=0
     0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
     3: ldc           #6                  // String project1 - foo()
     5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
     8: return
  LineNumberTable:
    line 8: 0
    line 9: 8
\end{verbatim}

\section{Implementare}\label{implementare}

\subsection{Deserializare}\label{deserializare}

Prima problema intalnita in construirea optimizatorului este
serializarea si deserializarea fisierelor clasa. Problema aceasta a fost
rezolvata folosind clasa \texttt{ClassReader}:

\begin{Shaded}
	\begin{Highlighting}[]
		\CommentTok{/// This class handles the parsation (deserialization and serialization) of}
		\CommentTok{/// Java's .class files.}
		\CommentTok{/// Normal usage should be:}
		\CommentTok{/// 1. Reading the binary data (for example, from a file on disk)}
		\CommentTok{/// 2. Instantiating this ClassReader.}
		\CommentTok{/// 3. Parsing the actual file.}
		\KeywordTok{struct}\NormalTok{ ClassReader \{}
		\KeywordTok{private}\NormalTok{:}
		\CommentTok{/// The binary representation of the class being parser.}
		\NormalTok{    BytesParser }\VariableTok{m_bparser}\NormalTok{;}

		\CommentTok{/// The class file that is being populated as the parsing progresses.}
		\NormalTok{    ClassFile }\VariableTok{m_cf}\NormalTok{;}

		\KeywordTok{public}\NormalTok{:}
		\CommentTok{/// Initialize the reader, with the binary `data` of the class file.}
		\NormalTok{    ClassReader(}\BuiltInTok{std::}\NormalTok{vector<}\DataTypeTok{uint8_t}\NormalTok{> data);}

		\CommentTok{/// Parse an entire class file.}
		\CommentTok{/// This is the method that you most likely want to use.}
		\NormalTok{    ClassFile deserialize();}

		\KeywordTok{private}\NormalTok{:}
		\CommentTok{/// Parses a constant from the data buffer, and returns the data}
		\CommentTok{/// and how many slots it takes up in the constant table.}
		\NormalTok{    cp_info parse_cp_info();}

		\CommentTok{/// Parses a field_info struct from the data buffer.}
		\NormalTok{    field_info parse_field_info();}

		\CommentTok{/// Parses a method_info struct from the data buffer.}
		\NormalTok{    method_info parse_method_info();}

		\CommentTok{/// Asserts that `idx` is an index into the constant pool, tagged with}
		\CommentTok{/// `tag`.}
		\DataTypeTok{void}\NormalTok{ expect_cpool_entry(}\DataTypeTok{int}\NormalTok{ idx, cp_info::Tag tag) }\AttributeTok{const}\NormalTok{;}
		\NormalTok{\};}
	\end{Highlighting}
\end{Shaded}

{[}1{]} https://github.com/trizen/language-benchmarks

{[}2{]} https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html

https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html

{[}4{]}
https://docs.oracle.com/javase/7/docs/technotes/tools/windows/javap.html

\end{document}
